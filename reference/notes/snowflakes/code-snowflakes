### adding a hash function to the standard namespace:

```
namespace std {

template<>
struct hash<utils::Entity> {
    typedef utils::Entity argument_type;
    typedef size_t result_type;
    result_type operator()(argument_type const& e) const {
        return e.getId();
    }
};

} // namespace std
```

### for a class with plenty of operator overloads:

```
class UTILS_PUBLIC Entity {
public:
    // this can be used to create an array of to-be-filled entities (see create())
    Entity() noexcept = default;

    // Entities can be copied
    Entity(const Entity& e) noexcept = default;
    Entity(Entity&& e) noexcept = default;
    Entity& operator=(const Entity& e) noexcept = default;
    Entity& operator=(Entity&& e) noexcept = default;

    // Entities can be compared
    bool operator==(Entity e) const { return e.mIdentity == mIdentity; }
    bool operator!=(Entity e) const { return e.mIdentity != mIdentity; }

    // Entities can be sorted
    bool operator<(Entity e) const { return e.mIdentity < mIdentity; }

    bool isNull() const noexcept {
        return mIdentity == 0;
    }

    // an id that can be used for debugging/printing
    uint32_t getId() const noexcept {
        return mIdentity;
    }

    explicit operator bool() const noexcept { return !isNull(); }

    void clear() noexcept  { mIdentity = 0; }

    // Exports an entity to an int32_t which can be used "as is" in the Java programing language.
    static int32_t smuggle(Entity entity) noexcept {
        return int32_t(entity.getId());
    }

    // Imports an entity from an int32_t generated by smuggle() above.
    static Entity import(int32_t identity) noexcept {
        return Entity{ Type(identity) };
    }

private:
    friend class EntityManager;
    friend class EntityManagerImpl;
    friend struct std::hash<Entity>;
    using Type = uint32_t;

    explicit Entity(Type identity) noexcept : mIdentity(identity) { }

    Type mIdentity = 0;
};

} // namespace utils
```

